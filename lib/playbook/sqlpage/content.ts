import z from "@zod/zod";
import { Code } from "types/mdast";
import {
  CodeFrontmatter,
  codeFrontmatter,
} from "../../axiom/mdast/code-frontmatter.ts";
import { Directive, Materializable } from "../../axiom/projection/playbook.ts";
import { isImportPlaceholder } from "../../axiom/remark/import-placeholders-generator.ts";
import {
  ensureLanguageByIdOrAlias,
  languageHandlers,
} from "../../universal/code.ts";
import { isAsyncIterator } from "../../universal/collectable.ts";
import { RenderResult } from "../../universal/render.ts";
import {
  provenanceResource,
  ResourceProvenance,
} from "../../universal/resource.ts";
import {
  isRouteSupplier,
  mutateRoutePaths,
  PageRoute,
  pageRouteSchema,
  RouteSupplier,
} from "../../universal/route.ts";
import {
  hexOfUint8,
  hexOfUint8Postgres,
  literal,
} from "../../universal/sql-text.ts";
import { safeJsonStringify } from "../../universal/tmpl-literal-aide.ts";

export const sqlCodeCellLangId = "sql" as const;
export const sqlCodeCellLangSpec = ensureLanguageByIdOrAlias(sqlCodeCellLangId);

export type SqlPagePath =
  & {
    readonly path: string;
    readonly sql: string; // usually '${path}'
    readonly absURL: () => string; // usually (COALESCE(sqlpage.environment_variable('SQLPAGE_SITE_PREFIX'), '') || '${path}')
    readonly homePath: () => string; // usually ('${path}' || '/index.sql')
    readonly isRoute: boolean;
  }
  & (
    | {
      readonly nature: "route";
      readonly isRoute: true;
    } & RouteSupplier
    | {
      readonly nature: "path";
      readonly isRoute: false;
    }
  );

export function sqlPagePath(candidate: string | PageRoute): SqlPagePath {
  const sql = literal(
    typeof candidate === "string" ? candidate : candidate.path,
  );
  const absURL = () =>
    `(COALESCE(sqlpage.environment_variable('SQLPAGE_SITE_PREFIX'), '') || ${sql})`;
  const homePath = () => `(${sql} || '/index.sql')`;

  if (typeof candidate === "string") {
    return {
      nature: "path",
      isRoute: false,
      path: candidate,
      sql,
      absURL,
      homePath,
    };
  } else {
    return {
      nature: "route",
      isRoute: true,
      route: candidate,
      sql,
      path: candidate.path,
      absURL,
      homePath,
    };
  }
}

export function sqlPagePathsFactory() {
  const encountered = new Map<string, SqlPagePath>();
  return {
    sqlPagePath: (candidate: Parameters<typeof sqlPagePath>[0]) => {
      const key = typeof candidate === "string" ? candidate : candidate.path;
      let spp = encountered.get(key);
      if (!spp) {
        spp = sqlPagePath(candidate);
        encountered.set(key, spp);
      }
      return spp;
    },
  };
}

/** Common fields present on all SqlPageFile variants */
type SqlPageFileBase = {
  /** Discriminator */
  readonly kind: "head_sql" | "tail_sql" | "sqlpage_file_upsert";
  /** Relative path (e.g., "sql.d/head/001.sql", "admin/index.sql") */
  readonly path: string;
  /** File contents (originates from cell.source, may be mutated for interpolations) */
  contents: string | Uint8Array | ReadableStream<Uint8Array>;
  /** Optional timestamp (not used in DML; engine time is used) */
  readonly lastModified?: Date;
  /** The notebook/playbook cell this file originated from, if any */
  readonly cell?: Code | Materializable | Directive;
};

/** Minimal variant for static head/tail SQL files */
export type SqlPageHeadOrTail =
  & SqlPageFileBase
  & {
    readonly kind: "head_sql" | "tail_sql";
    // No extra fields allowed here — intentionally minimal
  };

/** Extended variant for files that are upserted/generated by the engine */
export type SqlPageFileUpsert =
  & SqlPageFileBase
  & {
    readonly kind: "sqlpage_file_upsert";
    readonly asErrorContents: (text: string, error: unknown) => string;
    readonly isBinary: false | ReadableStream<Uint8Array>;
    readonly isAutoGenerated?: boolean;
    readonly isPartial?: boolean;
    readonly isUnsafeInterpolatable?: boolean;
    isInterpolated?: boolean;
    readonly isInjectableCandidate?: boolean;
    partialsInjected?: RenderResult["injectedTmpls"];
    error?: unknown;
  };

/** Discriminated union */
export type SqlPageContent = SqlPageHeadOrTail | SqlPageFileUpsert;

/** Wrapper type for contributors */
export type SqlPageFileContributor = {
  readonly sqlPageFile: SqlPageContent;
};

/** Narrow to any SqlPageFile */
export function isSqlPageContent(o: unknown): o is SqlPageContent {
  if (!o || typeof o !== "object") return false;
  const a = o as Partial<SqlPageContent>;
  return typeof a.kind === "string" && typeof a.path === "string" &&
    "contents" in a;
}

/** Narrow to the minimal head/tail variant */
export function isSqlPageHeadOrTail(o: SqlPageContent): o is SqlPageHeadOrTail {
  return o.kind === "head_sql" || o.kind === "tail_sql";
}

/** Narrow to the extended upsert variant */
export function isSqlPageFileUpsert(o: SqlPageContent): o is SqlPageFileUpsert {
  return o.kind === "sqlpage_file_upsert";
}

/** Narrow contributor wrapper */
export function isSqlPageFileContributor(
  o: unknown,
): o is SqlPageFileContributor {
  return !!o && typeof o === "object" && "sqlPageFile" in o &&
    isSqlPageContent(o.sqlPageFile);
}

export type SqlPageContentStream =
  | SqlPageContent
  | AsyncIterable<SqlPageContent>
  | AsyncIterator<SqlPageContent>;

export async function* normalizeSPC(
  input: SqlPageContentStream,
): AsyncIterable<SqlPageContent> {
  // Single Source object
  if (isSqlPageContent(input)) {
    yield input;
  }

  // Async iterator / async iterable of Source
  const it = isAsyncIterator(input)
    ? (input as AsyncIterator<SqlPageContentStream>)
    : (input as AsyncIterable<SqlPageContentStream>)[Symbol.asyncIterator]();

  while (true) {
    const { value, done } = await it.next();
    if (done) break;
    if (!isSqlPageContent(value)) {
      throw new TypeError("Stream yielded a non-SqlPageContent value");
    }
    yield value;
  }
}

export enum SqlPageFilesUpsertDialect {
  SQLite = "sqlite",
  PostgreSQL = "postgres",
}

/**
 * Build DML statements to upsert files into a SQLPage virtual-files table.
 * dialect "sqlite":
 *   INSERT INTO sqlpage_files (path, contents, last_modified) VALUES ('…','…', CURRENT_TIMESTAMP)
 *   ON CONFLICT(path) DO UPDATE
 *     SET contents = excluded.contents,
 *         last_modified = CURRENT_TIMESTAMP
 *     WHERE sqlpage_files.contents <> excluded.contents;
 *
 * Returns one object per file, tagged with kind: "sqlpage_file_insert".
 * On conflict when contents differ, last_modified is set by the SQL engine (CURRENT_TIMESTAMP).
 * If contents are identical, the row is left unchanged.
 */
export async function sqlPageFilesUpsertDML(
  spcStream: SqlPageContentStream,
  opts: {
    dialect: SqlPageFilesUpsertDialect;
    includeSqlPageFilesTable?: boolean;
  },
) {
  if (
    opts.dialect !== SqlPageFilesUpsertDialect.SQLite &&
    opts.dialect !== SqlPageFilesUpsertDialect.PostgreSQL
  ) {
    throw new Error(`Unsupported dialect: ${opts.dialect}`);
  }

  const esc = (s: string) => s.replaceAll("'", "''");

  const asText = async (
    s: string | Uint8Array | ReadableStream<Uint8Array>,
  ): Promise<string> => {
    if (typeof s === "string") return s;
    if (s instanceof Uint8Array) {
      return new TextDecoder().decode(s);
    }

    // Treat as ReadableStream<Uint8Array>
    const reader = s.getReader();
    const chunks: Uint8Array[] = [];
    while (true) {
      const { done, value } = await reader.read();
      if (done) break;
      if (value) chunks.push(value);
    }
    const totalLength = chunks.reduce((n, c) => n + c.length, 0);
    const bytes = new Uint8Array(totalLength);
    let offset = 0;
    for (const c of chunks) {
      bytes.set(c, offset);
      offset += c.length;
    }
    return new TextDecoder().decode(bytes);
  };

  const quoted = async (
    s: string | Uint8Array | ReadableStream<Uint8Array>,
  ): Promise<string> => {
    if (typeof s === "string") return `'${esc(s)}'`;
    if (s instanceof Uint8Array) {
      return opts.dialect === SqlPageFilesUpsertDialect.PostgreSQL
        ? hexOfUint8Postgres(s)
        : hexOfUint8(s);
    }

    const reader = s.getReader();
    const chunks: Uint8Array[] = [];
    while (true) {
      const { done, value } = await reader.read();
      if (done) break;
      if (value) chunks.push(value);
    }
    const bytes = new Uint8Array(chunks.reduce((n, c) => n + c.length, 0));
    let offset = 0;
    for (const c of chunks) {
      bytes.set(c, offset);
      offset += c.length;
    }
    return opts.dialect === SqlPageFilesUpsertDialect.PostgreSQL
      ? hexOfUint8Postgres(bytes)
      : hexOfUint8(bytes);
  };

  const list = await Array.fromAsync(normalizeSPC(spcStream));

  const headSql = await Promise.all(
    list
      .filter((e) => e.kind === "head_sql")
      .map((spf) => asText(spf.contents)),
  );

  const tailSql = await Promise.all(
    list
      .filter((e) => e.kind === "tail_sql")
      .map((spf) => asText(spf.contents)),
  );

  const upserts = await Promise.all(
    list
      .filter((e) => e.kind === "sqlpage_file_upsert")
      .map(async (f) => {
        const pathLit = `'${esc(f.path)}'`;
        const bodyLit = await quoted(f.contents);
        return `INSERT INTO sqlpage_files (path, contents, last_modified) VALUES (${pathLit}, ${
          (opts.dialect === SqlPageFilesUpsertDialect.PostgreSQL &&
              typeof f.contents === "string")
            ? `convert_to(${bodyLit}, 'UTF8')`
            : bodyLit
        }, CURRENT_TIMESTAMP) ` +
          `ON CONFLICT(path) DO UPDATE SET contents = excluded.contents, last_modified = CURRENT_TIMESTAMP ` +
          `WHERE sqlpage_files.contents <> excluded.contents;`;
      }),
  );

  return [
    opts.includeSqlPageFilesTable
      ? `CREATE TABLE IF NOT EXISTS "sqlpage_files" ("path" VARCHAR PRIMARY KEY NOT NULL, "contents" ${
        opts.dialect === SqlPageFilesUpsertDialect.PostgreSQL ? "BYTEA" : "TEXT"
      } NOT NULL, "last_modified" TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP);`
      : "-- sqlpage_files DDL not requested",
    ...headSql,
    ...upserts,
    ...tailSql,
  ];
}

export function mutateRouteInCellAttrs(
  cell: Materializable,
  identity: string,
  registerIssue?: (message: string, error?: unknown) => void,
  candidateAnns?: unknown, // if routes were supplied in annotation
) {
  const validated = (route: unknown) => {
    const parsed = z.safeParse(pageRouteSchema, route);
    if (!parsed.success) {
      registerIssue?.(
        `Zod error parsing route: ${z.prettifyError(parsed.error)}`,
        parsed.error,
      );
      return false;
    }
    return true;
  };

  // if no route was supplied in the cell attributes, use what's in annotations
  if (!isRouteSupplier(cell.materializationAttrs) && candidateAnns) {
    const attrs = (cell.materializationAttrs ??= {});
    attrs.route = candidateAnns;
    const mrp = mutateRoutePaths(attrs.route as PageRoute, identity);
    return mrp ?? validated(attrs.route);
  }

  // if route was supplied in the cell attributes, merge with annotations with
  // what's in the annotations overriding what's in cell attributes
  if (isRouteSupplier(cell.materializationAttrs) && candidateAnns) {
    // deno-lint-ignore no-explicit-any
    (cell.materializationAttrs as any).route = {
      ...cell.materializationAttrs.route,
      ...candidateAnns,
    };
    const mrp = mutateRoutePaths(
      cell.materializationAttrs.route as PageRoute,
      identity,
    );
    return mrp || validated(cell.materializationAttrs.route);
  }

  return false;
}

export function contentSuppliers() {
  const sqlSPF = (
    path: string,
    contents: string,
    candidate?: Partial<SqlPageContent>,
  ): SqlPageContent => ({
    kind: candidate?.kind ?? "sqlpage_file_upsert",
    path,
    contents,
    asErrorContents: (text) => text.replaceAll(/^/gm, "-- "),
    isBinary: false,
    ...candidate,
  });

  const jsonSPF = (
    path: string,
    contents: string,
    candidate?: Partial<SqlPageContent>,
  ): SqlPageContent => ({
    kind: candidate?.kind ?? "sqlpage_file_upsert",
    path,
    contents,
    asErrorContents: (text, error) => safeJsonStringify({ text, error }),
    isBinary: false,
    ...candidate,
  });

  const contentsFromResource = async (rp: ResourceProvenance) => {
    let contents: SqlPageFileUpsert["contents"];
    let isBinary: SqlPageFileUpsert["isBinary"];
    const resource = provenanceResource(rp);
    if (resource.strategy.encoding === "utf8-binary") {
      contents = await resource.stream();
      isBinary = contents;
    } else {
      contents = await resource.text();
      isBinary = false as const;
    }
    return { contents, isBinary };
  };

  const contents = async (code: Code, codeFM: CodeFrontmatter | null) => {
    if (isImportPlaceholder(code)) {
      return await contentsFromResource(code.importSpecProvenance);
    } else {
      if (
        codeFM?.pi && "import" in codeFM.pi.flags &&
        typeof codeFM.pi.flags.import === "string"
      ) {
        return await contentsFromResource({ path: codeFM.pi.flags.import });
      } else {
        return { contents: code.value, isBinary: false as const };
      }
    }
  };

  const langHandlers = languageHandlers<
    [Materializable, {
      registerIssue: (message: string, error?: unknown) => void;
    }],
    SqlPageContent | false | Promise<SqlPageContent | false>
  >({
    defaultHandler: async (materializable) => {
      const codeFM = codeFrontmatter(materializable);
      if (!(codeFM?.pi.flags) || !("spc" in codeFM?.pi.flags)) return false;
      const path = materializable.materializableIdentity;
      return {
        kind: "sqlpage_file_upsert",
        path,
        asErrorContents: (supplied) => supplied,
        isUnsafeInterpolatable: materializable.materializationArgs.interpolate,
        isInjectableCandidate: materializable.materializationArgs.injectable,
        cell: materializable,
        ...await contents(materializable, codeFM),
      };
    },
  });

  langHandlers.register(
    sqlCodeCellLangSpec,
    async (materializable, { registerIssue }) => {
      const path = materializable.materializableIdentity;
      mutateRouteInCellAttrs(materializable, path, registerIssue);
      return {
        kind: "sqlpage_file_upsert",
        path,
        isRoutable: true,
        asErrorContents: (text) => text.replaceAll(/^/gm, "-- "),
        isUnsafeInterpolatable: true,
        isInjectableCandidate: true,
        cell: materializable,
        ...await contents(materializable, codeFrontmatter(materializable)),
      };
    },
  );

  langHandlers.register(
    ensureLanguageByIdOrAlias("css"),
    async (materializable) => ({
      kind: "sqlpage_file_upsert",
      path: materializable.materializableIdentity,
      isRoutable: false,
      asErrorContents: (text) => text.replaceAll(/^/gm, "// "),
      isUnsafeInterpolatable: true,
      isInjectableCandidate: false,
      cell: materializable,
      ...await contents(materializable, codeFrontmatter(materializable)),
    }),
  );

  langHandlers.register(
    ensureLanguageByIdOrAlias("typescript"),
    async (materializable) => ({
      kind: "sqlpage_file_upsert",
      path: materializable.materializableIdentity,
      isRoutable: false,
      asErrorContents: (text) => text.replaceAll(/^/gm, "// "),
      isUnsafeInterpolatable: true,
      isInjectableCandidate: false,
      cell: materializable,
      ...await contents(materializable, codeFrontmatter(materializable)),
    }),
  );

  return { ...langHandlers, sqlSPF, jsonSPF, contents, contentsFromResource };
}
